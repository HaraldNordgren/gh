// +build ignore

package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"
	"tmpl"
	"unicode"

	"github.com/PuerkitoBio/goquery"
)

const docURL = "https://developer.github.com/v3/activity/events/types"

var output string

type rawEvent struct {
	Name        string
	PayloadJSON string
}

type member struct {
	Name string
	Typ  string
	Tag  string
}

type object struct {
	Name    string
	Members []member
}

type memberSlice []member

func (m memberSlice) Len() int           { return len(m) }
func (m memberSlice) Less(i, j int) bool { return m[i].Name < m[j].Name }
func (m memberSlice) Swap(i, j int)      { m[i], m[j] = m[j], m[i] }
func (m memberSlice) Sort()              { sort.Sort(m) }

type objectSlice []object

func (o objectSlice) Len() int           { return len(o) }
func (o objectSlice) Less(i, j int) bool { return o[i].Name < o[j].Name }
func (o objectSlice) Swap(i, j int)      { o[i], o[j] = o[j], o[i] }
func (o objectSlice) Sort()              { sort.Sort(o) }

const header = `// Created by go generate; DO NOT EDIT

package ghops

import (
	"reflect"
	"time"
)

var payloadTypes = map[string]reflect.Type{
{{range $_, $event := .}}	"{{snakeCase $event.Name}}": reflect.TypeOf((*{{$event.Name}})(nil)).Elem(),
{{end}}
}
`

const types = `{{range $_, $o := .}}// {{$o.Name}} was autogenerated by go generate. To see more details about this
// payload type visit https://developer.github.com/v3/activity/events/types.
type {{$o.Name}} struct {
{{range $_, $m := $o.Members}}	{{$m.Name}} {{$m.Typ}} ` + "`json:\"{{$m.Tag}}\"`" + `
{{end}}
}
{{end}}
// Files was autogenerated by go generate. To see more details about this
// payload type visit https://developer.github.com/v3/activity/events/types.
type Files map[string]File
`

var funcs = map[string]interface{}{
	"snakeCase": func(s string) string {
		if i := strings.Index(s, "Event"); i != -1 {
			s = s[:i]
		}
		return snakeCase(s)
	},
}

var tmplHeader = template.Must(template.New("payloads").Funcs(funcs).Parse(header))
var tmplTypes = template.Must(template.New("payloads").Parse(types))

// Those keys that are assigned to null in example JSON payloads lack type
// information. Instead the value types are mapped here by hand.
var hardcodedTypes = map[string]string{
	"user":        "User",
	"position":    "int",
	"line":        "int",
	"closed_at":   "time.Time",
	"merged_at":   "time.Time",
	"body":        "string",
	"path":        "string",
	"homepage":    "string",
	"language":    "string",
	"mirror_url":  "string",
	"assignee":    "string",
	"milestone":   "string",
	"message":     "string",
	"merged_by":   "string",
	"base_ref":    "string",
	"summary":     "string",
	"name":        "string",
	"target_url":  "string",
	"description": "string",
}

// File is a value of gist's Files map, it's handled separately as
// linearObjects does not handle type aliasing.
//
// https://developer.github.com/v3/gists/
var hardcodedFileType = object{
	Name: "File",
	Members: []member{
		{
			Name: "Size",
			Typ:  "int",
			Tag:  "size",
		},
		{
			Name: "RawURL",
			Typ:  "string",
			Tag:  "raw_url",
		},
		{
			Name: "Type",
			Typ:  "string",
			Tag:  "type",
		},
		{
			Name: "Truncated",
			Typ:  "bool",
			Tag:  "truncated",
		},
		{
			Name: "Language",
			Typ:  "string",
			Tag:  "language",
		},
	},
}

func nonil(err ...error) error {
	for _, err := range err {
		if err != nil {
			return err
		}
	}
	return nil
}

func die(v interface{}) {
	fmt.Fprintln(os.Stderr, v)
	os.Exit(1)
}

func init() {
	flag.StringVar(&output, "o", "payloads.go", "")
	flag.Parse()
	if !filepath.IsAbs(output) {
		s, err := filepath.Abs(output)
		if err != nil {
			die(err)
		}
		output = s
	}
}

func snakeCase(s string) (t string) {
	for _, c := range s {
		if unicode.IsUpper(c) {
			t = t + "_" + string(unicode.ToLower(c))
		} else {
			t = t + string(c)
		}
	}
	return strings.Trim(t, "_")
}

func camelCase(s string) (t string) {
	up := true
	for _, r := range s {
		switch r {
		case ' ', '-', '_':
			up = true
		default:
			if up {
				t = t + string(unicode.ToUpper(r))
				up = false
			} else {
				t = t + string(r)
			}
		}
	}
	return t
}

var idiomaticReplacer = strings.NewReplacer("Url", "URL", "Id", "ID", "Html", "HTML", "Sha", "SHA")

func idiomatic(s string) string {
	return idiomaticReplacer.Replace(s)
}

func scrapPayload(s *goquery.Selection, n int) string {
	url, ok := s.Find("a").Attr("href")
	if !ok {
		die("unable to find URL for scrapping")
	}
	url = "https://developer.github.com" + url
	res, err := http.Get(url)
	if err != nil {
		die(err)
	}
	defer res.Body.Close()
	doc, err := goquery.NewDocumentFromReader(res.Body)
	if err != nil {
		die(err)
	}
	var payload string
	doc.Find(`div[class='content'] > pre[class='body-response'] > code[class^='language']`).Each(
		func(i int, s *goquery.Selection) {
			if i == n {
				payload = s.Text()
			}
		},
	)
	if payload == "" {
		die(fmt.Sprintf("unable to scrap %s (n=%d)", url, n))
	}
	return payload
}

func externalJSON(event *rawEvent, s *goquery.Selection) bool {
	switch event.Name {
	case "DownloadEvent":
		event.PayloadJSON = scrapPayload(s, 1)
		return true
	case "FollowEvent":
		event.PayloadJSON = scrapPayload(s, 0)
		return true
	case "GistEvent":
		event.PayloadJSON = fmt.Sprintf(`{"action":"create","gist":%s}`, scrapPayload(s, 1))
		return true
	case "ForkApplyEvent":
		event.PayloadJSON = `{"head":"master","before":"e51831b1","after":"0c72c758c"}`
		return true
	default:
		return false
	}
}

type node struct {
	name  string
	nodes map[string]interface{}
}

var setType = func() func(*member, interface{}, string, *[]node) {
	var setType func(*member, interface{}, string, *[]node)
	setType = func(m *member, v interface{}, parent string, stack *[]node) {
		switch v := v.(type) {
		case map[string]interface{}:
			if parent == m.Name {
				// Ignore members which are named after structs to not create
				// invalid recursive types.
				break
			}
			m.Typ = m.Name
			// Files is a member of a gist object, it's handled separately since
			// it's a map.
			//
			// https://developer.github.com/v3/gists/
			if m.Typ != "Files" {
				*stack = append(*stack, node{name: m.Name, nodes: v})
			}
		case bool:
			m.Typ = "bool"
		case float64:
			m.Typ = "int"
		case []interface{}:
			if len(v) == 0 {
				m.Typ = "[]string"
				break
			}
			var prev = *m
			var cur = *m
			for _, v := range v {
				setType(&cur, v, "", stack)
				if prev.Typ != "" && cur.Typ != prev.Typ {
					die(fmt.Sprintf("heterogeneous arrays not supported: %s, %s", prev.Typ, cur.Typ))
				}
				prev = cur
			}
			m.Typ = cur.Typ
		case string:
			switch err := (&time.Time{}).UnmarshalText([]byte(v)); err {
			case nil:
				m.Typ = "time.Time"
			default:
				m.Typ = "string"
			}
		default:
			typ, ok := hardcodedTypes[m.Tag]
			if !ok {
				die(fmt.Sprintf("unable to guess type for %s: %T", m.Name, v))
			}
			m.Typ = typ
		}

	}
	return setType
}()

func linearObjects(tree map[string]interface{}) (obj []object) {
	var stack = make([]node, 0, len(tree))
	for k, v := range tree {
		v, ok := v.(map[string]interface{})
		if !ok {
			die(fmt.Sprintf("%s is not a JSON object", k))
		}
		stack = append(stack, node{name: k, nodes: v})
	}
	obj = append(obj, hardcodedFileType)
	var nd node
	var visited = map[string]struct{}{"Files": {}}
	for n := len(stack); n != 0; n = len(stack) {
		nd, stack = stack[n-1], stack[:n-1]
		if _, ok := visited[nd.name]; ok {
			continue
		}
		o := object{Name: nd.name, Members: make([]member, 0, len(nd.nodes))}
		for k, v := range nd.nodes {
			m := member{Name: idiomatic(camelCase(k)), Tag: k}
			setType(&m, v, nd.name, &stack)
			o.Members = append(o.Members, m)
		}
		memberSlice(o.Members).Sort()
		obj = append(obj, o)
		visited[nd.name] = struct{}{}
	}
	objectSlice(obj).Sort()
	return obj
}

func main() {
	f, err := ioutil.TempFile(filepath.Split(output))
	if err != nil {
		die(err)
	}
	defer func() { nonil(f.Close(), os.Remove(f.Name())) }()
	res, err := http.Get(docURL)
	if err != nil {
		die(err)
	}
	defer res.Body.Close()
	doc, err := goquery.NewDocumentFromReader(res.Body)
	if err != nil {
		die(err)
	}
	var events []rawEvent
	var n int
	doc.Find(`div[class='content'] > h2[id$='event'],h3[id^='payload']+table,table+pre`).Each(
		func(i int, s *goquery.Selection) {
			switch {
			case n == len(events):
				events = append(events, rawEvent{Name: s.Text()})
			case externalJSON(&events[n], s):
				n++
			default:
				s.Find(`pre > code[class^='language']`).Each(
					func(_ int, s *goquery.Selection) {
						if events[n].PayloadJSON != "" {
							die(fmt.Sprintf("duplicate JSON payload for %q event (i=%d)", events[n].Name, i))
						}
						events[n].PayloadJSON = s.Text()
					})
				if events[n].PayloadJSON != "" {
					n++
				}
			}
		})
	for i := range events {
		switch {
		case !strings.HasSuffix(events[i].Name, "Event"):
			die(fmt.Sprintf("invalid event name: %q (i=%d)", events[i].Name, i))
		case events[i].PayloadJSON == "":
			die(fmt.Sprintf("empty payload for %q event (i=%d)", events[i].Name, i))
		}
	}
	log.SetOutput(ioutil.Discard)
	if err := tmplHeader.Execute(f, events); err != nil {
		die(err)
	}
	typeTree := make(map[string]interface{}, len(events))
	for _, event := range events {
		var v interface{}
		if err := json.Unmarshal([]byte(event.PayloadJSON), &v); err != nil {
			die(err)
		}
		typeTree[event.Name] = v
	}
	if err := tmplTypes.Execute(f, linearObjects(typeTree)); err != nil {
		die(err)
	}
	if err := nonil(f.Sync(), f.Close()); err != nil {
		die(err)
	}
	// os.Rename fails under Windows when target file exists.
	if err := nonil(os.RemoveAll(output), os.Rename(f.Name(), output)); err != nil {
		die(err)
	}
}
